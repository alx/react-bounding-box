(self.webpackChunkreact_bounding_box=self.webpackChunkreact_bounding_box||[]).push([[725],{"./src/react-bounding-box.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{A:()=>react_bounding_box});var react=__webpack_require__("./node_modules/react/index.js"),prop_types=__webpack_require__("./node_modules/prop-types/index.js"),prop_types_default=__webpack_require__.n(prop_types),seedrandom=__webpack_require__("./node_modules/seedrandom/index.js"),seedrandom_default=__webpack_require__.n(seedrandom);function createLogger(namespace){return{log(message,...args){false},info(message,...args){false},warn(message,...args){false},error(message,...args){false},debug(message,...args){false}}}const logger=createLogger();createLogger(),createLogger(),createLogger();var jsx_runtime=__webpack_require__("./node_modules/react/jsx-runtime.js");class Boundingbox extends react.Component{constructor(props){super(props),this.state={canvasCreated:!1,hoverIndex:-1,segmentColors:[]},props.segmentationJsonUrl&&fetch(props.segmentationJsonUrl).then(response=>response.json()).then(response=>{response.body&&response.body.predictions&&response.body.predictions[0]&&response.body.predictions[0].vals&&response.body.predictions[0].vals.length>0&&(this.setState({isSegmented:!1}),this.renderSegmentation(response.body.predictions[0].vals))})}componentDidMount(){if(!this.canvas)return void logger.warn("Canvas ref not available during componentDidMount");const ctx=this.canvas.getContext("2d"),background=new Image;background.src=this.props.options.base64Image?"data:image/png;base64,"+this.props.image:this.props.image,background.onload=()=>{if(!this.canvas)return void logger.warn("Canvas ref not available during image load");this.canvas.width=background.width,this.canvas.height=background.height,ctx.drawImage(background,0,0),this.renderBoxes();const hasSegmentedState=this.state.pixelSegmentation&&this.state.pixelSegmentation.length>0&&!this.state.isSegmented,hasSegmentedProps=this.props.pixelSegmentation&&this.props.pixelSegmentation.length>0&&!this.state.isSegmented,hasSegmentionMasks=this.props.segmentationMasks&&this.props.segmentationMasks.length>0&&!this.state.isSegmented;hasSegmentedState&&this.renderSegmentation(this.state.pixelSegmentation),hasSegmentedProps&&this.renderSegmentation(this.props.pixelSegmentation),hasSegmentionMasks&&this.renderSegmentationMasks(),this.canvas.onmousemove=e=>{const r=this.canvas.getBoundingClientRect(),scaleX=this.canvas.width/r.width,scaleY=this.canvas.height/r.height,x=(e.clientX-r.left)*scaleX,y=(e.clientY-r.top)*scaleY,selectedBox={index:-1,dimensions:null};this.props.boxes&&this.props.boxes.length>0?this.props.boxes.forEach((box,index)=>{if(!box||void 0===box)return null;const coord=box.coord?box.coord:box;let[bx,by,bw,bh]=[0,0,0,0];if(void 0!==coord.xmin&&void 0!==coord.xmax&&void 0!==coord.ymin&&void 0!==coord.ymax?[bx,by,bw,bh]=[Math.min(coord.xmin,coord.xmax),Math.min(coord.ymin,coord.ymax),Math.max(coord.xmin,coord.xmax)-Math.min(coord.xmin,coord.xmax),Math.max(coord.ymin,coord.ymax)-Math.min(coord.ymin,coord.ymax)]:[bx,by,bw,bh]=coord,x>=bx&&x<=bx+bw&&y>=by&&y<=by+bh){(!selectedBox.dimensions||bx>=selectedBox.dimensions[0]&&bx<=selectedBox.dimensions[0]+selectedBox.dimensions[2]&&by>=selectedBox.dimensions[1]&&by<=selectedBox.dimensions[1]+selectedBox.dimensions[3])&&(selectedBox.index=index,selectedBox.dimensions=box)}}):this.state.pixelSegmentation&&this.state.pixelSegmentation.length>0&&(selectedBox.index=this.state.pixelSegmentation[x+this.canvas.width*y]),this.props.onSelected(selectedBox.index),this.setState({hoverIndex:selectedBox.index})},this.canvas.onmouseout=()=>{this.props.onSelected(-1),this.setState({hoverIndex:-1})},this.canvas.onclick=e=>{const r=this.canvas.getBoundingClientRect(),scaleX=this.canvas.width/r.width,scaleY=this.canvas.height/r.height,x=(e.clientX-r.left)*scaleX,y=(e.clientY-r.top)*scaleY,selectedBox={index:-1,dimensions:null};this.props.boxes&&this.props.boxes.length>0?this.props.boxes.forEach((box,index)=>{if(!box||void 0===box)return null;const coord=box.coord?box.coord:box;let[bx,by,bw,bh]=[0,0,0,0];if(void 0!==coord.xmin&&void 0!==coord.xmax&&void 0!==coord.ymin&&void 0!==coord.ymax?[bx,by,bw,bh]=[Math.min(coord.xmin,coord.xmax),Math.min(coord.ymin,coord.ymax),Math.max(coord.xmin,coord.xmax)-Math.min(coord.xmin,coord.xmax),Math.max(coord.ymin,coord.ymax)-Math.min(coord.ymin,coord.ymax)]:[bx,by,bw,bh]=coord,x>=bx&&x<=bx+bw&&y>=by&&y<=by+bh){(!selectedBox.dimensions||bx>=selectedBox.dimensions[0]&&bx<=selectedBox.dimensions[0]+selectedBox.dimensions[2]&&by>=selectedBox.dimensions[1]&&by<=selectedBox.dimensions[1]+selectedBox.dimensions[3])&&(selectedBox.index=index,selectedBox.dimensions=box)}}):this.state.pixelSegmentation&&this.state.pixelSegmentation.length>0&&(selectedBox.index=this.state.pixelSegmentation[x+this.canvas.width*y]),this.props.onSelected&&this.props.onSelected(selectedBox.index)}}}componentDidUpdate(prevProps){if(prevProps.image!==this.props.image||prevProps.boxes!==this.props.boxes){const ctx=this.canvas.getContext("2d");if(ctx.clearRect(0,0,this.canvas.width,this.canvas.height),this.segCanvas){this.segCanvas.getContext("2d").clearRect(0,0,this.canvas.width,this.canvas.height)}const background=new Image;background.src=this.props.options.base64Image?"data:image/png;base64,"+this.props.image:this.props.image,background.onload=()=>{this.canvas.width!==background.width&&this.canvas.height!==background.height&&(this.canvas.width=background.width,this.canvas.height=background.height,ctx.drawImage(background,0,0),this.renderBoxes(this.props.boxes))},ctx.drawImage(background,0,0),this.renderBoxes(this.props.boxes)}prevProps.selectedIndex!==this.props.selectedIndex&&this.setState({hoverIndex:this.props.selectedIndex});this.props.pixelSegmentation&&this.props.pixelSegmentation.length>0&&prevProps.pixelSegmentation!==this.props.pixelSegmentation&&(this.setState({isSegmented:!1}),this.renderSegmentation(this.props.pixelSegmentation))}segmentColor(classIndex){const segmentColors=this.state.segmentColors;if(segmentColors[classIndex]&&3===segmentColors[classIndex].length)return segmentColors[classIndex];let r,g,b;if(this.props.segmentationColors&&this.props.segmentationColors[classIndex]){const hex=this.props.segmentationColors[classIndex],result=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);r=parseInt(result[1],16),g=parseInt(result[2],16),b=parseInt(result[3],16)}else{const random=seedrandom_default()(classIndex);r=Math.floor(255*random()),g=Math.floor(255*random()),b=Math.floor(255*random())}return segmentColors[classIndex]=[r,g,b],this.setState({segmentColors}),[r,g,b]}renderBox(box,index){if(!this.canvas)return logger.warn("Canvas ref not available during renderBox"),null;if(!box||void 0===box)return null;let color=this.props.options.colors.normal;this.state.hoverIndex>=0&&(color=this.props.options.colors.unselected),index===this.state.hoverIndex&&(color=this.props.options.colors.selected);let lineWidth=2;this.canvas.width>600&&(lineWidth=3),this.canvas.width>1e3&&(lineWidth=5),this.props.drawBox(this.canvas,box,color,lineWidth),box.label&&this.props.drawLabel(this.canvas,box)}renderBoxes(boxes){this.canvas?(void 0===boxes&&(boxes=this.props.boxes),null===boxes&&(boxes=[]),boxes.map((box,index)=>({box,index,selected:index===this.state.hoverIndex})).sort(a=>a.selected?1:-1).forEach(box=>this.renderBox(box.box,box.index))):logger.warn("Canvas ref not available during renderBoxes")}renderSegmentation(segmentation){let ctx=null,imgd=null;if(this.props.separateSegmentation&&this.segCanvas){this.segCanvas.width=this.canvas.width,this.segCanvas.height=this.canvas.height,ctx=this.segCanvas.getContext("2d"),imgd=ctx.getImageData(0,0,this.segCanvas.width,this.segCanvas.height);const pix=imgd.data;for(var i=0,j=0,n=pix.length;i<n;i+=4,j+=1){const segmentClass=segmentation[j],segmentColor=this.segmentColor(segmentClass);pix[i]=segmentColor[0],pix[i+1]=segmentColor[1],pix[i+2]=segmentColor[2],pix[i+3]=255}}else{ctx=this.canvas.getContext("2d"),imgd=ctx.getImageData(0,0,this.canvas.width,this.canvas.height);const pix=imgd.data;for(i=0,j=0,n=pix.length;i<n;i+=4,j+=1){const segmentClass=segmentation[j],segmentColor=this.segmentColor(segmentClass);pix[i]=Math.round((pix[i]+segmentColor[0])/2),pix[i+1]=Math.round((pix[i+1]+segmentColor[1])/2),pix[i+2]=Math.round((pix[i+2]+segmentColor[2])/2),pix[i+3]=200}}ctx.putImageData(imgd,0,0),this.setState({isSegmented:!0})}renderSegmentationMasks(){const{boxes,segmentationMasks,segmentationTransparency}=this.props;this.segCanvas.width=this.canvas.width,this.segCanvas.height=this.canvas.height;const ctx=this.segCanvas.getContext("2d");segmentationMasks.forEach((mask,index)=>{const segmentColor=this.segmentColor(boxes[index].label?boxes[index].label:index),maskData=ctx.getImageData(parseInt(boxes[index].xmin,10),parseInt(boxes[index].ymin,10),mask.width,mask.height);for(let i=0,j=0;i<maskData.data.length;j++,i+=4)mask.data[j]>0&&(maskData.data[i]=segmentColor[0],maskData.data[i+1]=segmentColor[1],maskData.data[i+2]=segmentColor[2],maskData.data[i+3]=segmentationTransparency);ctx.putImageData(maskData,parseInt(boxes[index].xmin,10),parseInt(boxes[index].ymin,10),0,0,mask.width,mask.height)}),this.setState({isSegmented:!0})}render(){return(0,jsx_runtime.jsxs)("div",{className:this.props.className,children:[(0,jsx_runtime.jsx)("canvas",{className:"boundingBoxCanvas",style:this.props.options.style,ref:canvas=>{this.canvas=canvas}}),this.props.separateSegmentation?(0,jsx_runtime.jsx)("canvas",{className:"boundingSegmentationCanvas",style:this.props.options.styleSegmentation,ref:canvas=>{this.segCanvas=canvas}}):null]})}}Boundingbox.propTypes={image:prop_types_default().string,boxes:prop_types_default().oneOfType([prop_types_default().arrayOf(prop_types_default().array),prop_types_default().arrayOf(prop_types_default().object)]),separateSegmentation:prop_types_default().bool,segmentationJsonUrl:prop_types_default().string,segmentationColors:prop_types_default().array,segmentationMasks:prop_types_default().array,segmentationTransparency:prop_types_default().number,selectedIndex:prop_types_default().number,drawBox:prop_types_default().func,drawLabel:prop_types_default().func,onSelected:prop_types_default().func,options:prop_types_default().shape({colors:prop_types_default().shape({normal:prop_types_default().string,selected:prop_types_default().string,unselected:prop_types_default().string}),style:prop_types_default().object,styleSegmentation:prop_types_default().object,base64Image:prop_types_default().bool})},Boundingbox.defaultProps={boxes:[],separateSegmentation:!1,segmentationTransparency:190,onSelected(){},drawBox(canvas,box,color,lineWidth){if(!box||void 0===box)return null;const ctx=canvas.getContext("2d"),coord=box.coord?box.coord:box;let[x,y,width,height]=[0,0,0,0];void 0!==coord.xmin&&void 0!==coord.xmax&&void 0!==coord.ymin&&void 0!==coord.ymax?[x,y,width,height]=[Math.min(coord.xmin,coord.xmax),Math.min(coord.ymin,coord.ymax),Math.max(coord.xmin,coord.xmax)-Math.min(coord.xmin,coord.xmax),Math.max(coord.ymin,coord.ymax)-Math.min(coord.ymin,coord.ymax)]:[x,y,width,height]=coord,x<lineWidth/2&&(x=lineWidth/2),y<lineWidth/2&&(y=lineWidth/2),x+width>canvas.width&&(width=canvas.width-lineWidth-x),y+height>canvas.height&&(height=canvas.height-lineWidth-y);const tenPercent=width/10,ninetyPercent=9*tenPercent;ctx.strokeStyle=color,ctx.lineWidth=lineWidth,ctx.beginPath(),ctx.moveTo(x+tenPercent,y),ctx.lineTo(x,y),ctx.lineTo(x,y+height),ctx.lineTo(x+tenPercent,y+height),ctx.stroke(),ctx.beginPath(),ctx.moveTo(x+ninetyPercent,y),ctx.lineTo(x+width,y),ctx.lineTo(x+width,y+height),ctx.lineTo(x+ninetyPercent,y+height),ctx.stroke()},drawLabel(canvas,box){if(!box||void 0===box)return null;const ctx=canvas.getContext("2d"),coord=box.coord?box.coord:box;let[x,y,_width,height]=[0,0,0,0];void 0!==coord.xmin&&void 0!==coord.xmax&&void 0!==coord.ymin&&void 0!==coord.ymax?[x,y,_width,height]=[Math.min(coord.xmin,coord.xmax),Math.min(coord.ymin,coord.ymax),Math.max(coord.xmin,coord.xmax)-Math.min(coord.xmin,coord.xmax),Math.max(coord.ymin,coord.ymax)-Math.min(coord.ymin,coord.ymax)]:[x,y,_width,height]=coord,ctx.font="60px Arial",ctx.fillStyle="rgba(225,0,0,1)",ctx.fillText(box.label,x,y+height)},options:{colors:{normal:"rgba(255,225,255,1)",selected:"rgba(0,225,204,1)",unselected:"rgba(100,100,100,1)"},style:{maxWidth:"100%",maxHeight:"90vh"},styleSegmentation:{maxWidth:"100%",maxHeight:"90vh",pointerEvents:"none"},base64Image:!1}};const react_bounding_box=Boundingbox},"?d4c0":()=>{}}]);